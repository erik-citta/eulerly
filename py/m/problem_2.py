#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

########################################################
# Take 1, naive
########################################################
def solve_naive(n=4000000):
    even_sum = 0
    a, b = 1, 1
    while b < n:
        a, b = b, a + b
        if (b % 2 ==0):
            even_sum += b
    return even_sum

from math import floor, log

########################################################
# Take 2, "With a little help from my friend(s)"
########################################################

# The sum of the even terms is half the sum of the whole sequence.
#
# 
# Take a triplet of fibonacci numbers:
# F(1) = a                  // odd (e.g. 1)
# F(2) = b                  // odd (e.g. 1)
# F(3) = a + b              // even (since it's odd + odd)  (e.g. 2)
#
# Let's sum the whole triplet:
# F(1) + F(2) + F(3) = (a) + (b) + (a + b) = 2 (a + b) = 2 F(3)
#
#           F(1) + F(2) + F(3)
# so F(3) = ------------------
#                   2
# 
# But this is true for every triplet F(k + 1) + F(k + 2) + F(k + 3) = 2 F(k + 3)      where k is multiple of 3 
# since the odd, odd, even is repeated.
#
# So the sum of every "third term" (i.e. the even) for each triplet is:
# 
#                                         F(1) + F(2) + F(3)   F(4) + F(5) + F(6)          1
# SUM_OF_EVEN_TERMS = F(3) + F(6) + ... = ------------------ + ------------------ + ... = --- SUM_OF_THE_WHOLE_SEQUENCE
#                                                 2                    2                   2
#

def n(fib):
    '''
    Given a number, which is the nearest lower index of a fibonacci number?  (wikipedia)
    '''
    return int(floor(log(fib * sqrt5 + 0.5, phi)))

def floor_m(n, factor):
    '''
    Return n's next lower multiple of factor. E.g. floor_m(10, 3) returns 9 (9 is 10's nearest lower multiple of 3)
    '''
    return n - (n % factor)

sqrt5 = 5 ** 0.5            # square root of 5, precalculate it.
phi = (1 + sqrt5) / 2       # golden ratio.

def fib_binet(n):
    '''
    Nth fibonacci number using binet's closed formula  (wikipedia)
    '''
    return int(round((phi ** n) / sqrt5))

def fib_partial_sum(n):
    '''
    Sum of the whole fib serie up to n    (wikipedia)
    '''
    return fib_binet(n + 2) - 1

def solve(threshold=4000000):
    fib_terms_count = n(threshold)                              # how many fib numbers are below 4 millions? 

    last_even_fib_term = floor_m(fib_terms_count, 3)            # which is the index of the last even fib number? 
                                                                # every third Fibonacci number is even (sum of the previous 2 odds)

    return fib_partial_sum(last_even_fib_term) / 2              # sum of the even terms is half the total sum (see above)
        

if __name__ == "__main__":
    print solve_naive()
    print solve()
    

    
